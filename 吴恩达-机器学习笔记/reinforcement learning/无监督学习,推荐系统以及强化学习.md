---
title: 无监督学习,推荐系统以及强化学习
date: 2025-07-25 18:49:23
tags: [AI, unsupervised learning, recommender system,  reinforcement learning]
comment: true
mathjax: true
---

# 无监督学习，推荐系统以及强化学习

## 无监督学习

### 聚类

#### K-means算法

* 随机猜测簇质心点位置
* 遍历所有的点，检查这些点距离哪个质心更近，并将点分配给最近的簇质心
* 分配好后，依次查看每个簇覆盖的点，并对这些点取平均值，并将簇质心移动到平均值的位置
* 再次查看所有点，检查这些点是否更接近另外的簇质心，而不是当前分配的簇质心，并重新将这些点分配给最近的簇质心
* 再次重新取均值移动簇质心
* 重复执行前两步直到簇质心不再移动

#### 算法实现

* 随机初始化$K$个簇质心$\mu_{1}, \mu_{2}, \ldots, \mu_{K}$
* 重复以下步骤
  * 1.将点分配给簇质心
  * `for i = 1 to m`
    * $c^{(i)}$`:=index(from 1 to K) of cluster centroid closest to `$x^{(i)}$
  * 2.移动簇质心
  * `for k = 1 to K`
    * $\mu_{k}$`:= average(mean) of points assigned to cluster k`

#### 优化目标

**前言：**

* $c^{(i)}$ : 表示$x^{(i)}$(即第$i$个样本)被分配给的簇质心的序号
* $\mu_{k}$ : 第$k$个簇质心(也就是聚类中心)的位置 
* $\mu_{c^{(i)}}$ : 即若想知道第$x^{(i)}$个样本所属的簇质心(聚类中心)的位置，就可以通过$c^{(i)}$知道所属的簇质点序号，再根据簇质点序号，查看$\mu_{c^{(i)}}$，即第$c^{(i)}$个簇质心的位置

**代价函数(Cost function)/失真函数(Distortion function)：**

* $J(c^{(1)}, \ldots, c^{(m)}, \mu_{1}, \ldots, \mu_{k}) = \frac{1}{m}\sum\limits_{i = 1}^m{||x^{(i)} - \mu_{c^{(i)}}||^{2}}$

#### 初始化K-means

* 选择$K \lt m$
* 从$m$个训练样本中随机的取出$K$个
* 令$\mu_1, \mu_2, \ldots, \mu_k$等于选择的$K$个样本

**随机初始化**

* `For i = 1 to 100 {`(至少尝试$50 \sim 100$次，但最好不要超过$1000$次)
  * 随机初始化$K$个簇质心(选择$K$个训练集中的样本)
  * 运行`K-means`算法，得到对应的$c^{(1)}, \ldots, c^{(m)}, \mu_{1}, \ldots, \mu_{k}$
  * 计算代价函数(失真函数)
  * $J(c^{(1)}, \ldots, c^{(m)}, \mu_{1}, \ldots, \mu_{k})$
* `}`
* 选择代价最低的一组聚类

#### 聚类数量选择($K$的选择)

需要选择一个合适的$K$值时，往往会尝试采用多个$k$的取值，并用于训练模型后绘制出

**ELBO(elbow method)**

将代价函数作为聚类数量的函数进行观察，看是否有一个弯折点(如下左图，即类似手肘的弯曲，开始下降较快，经过某个点后变缓，这个点就是弯折点)

**注：** `ELBO`算法使用较少，如下右图，实际上很多情况下函数变化是比较平缓，那就会导致最后选择的$K$就是尝试中最大的$K$。

![](https://github.com/1830125598/DeepLearning/raw/4c3801d4b904707199c6fcaefb602b31fcfc33d6/unsupervised%20learning/ELBO%E7%AE%97%E6%B3%95.png)

**在后续用途中的表现来评估**

先对模型进行训练，后续再根据具体的情况来评估哪个$K$值比较合适

### Anomaly Detection(异常检测)

#### Density estimation(密度估计)

如下图，正常运行时，多数样本必然会聚集在密度高的中心区域，而机器故障时，样本会偏离这个区域，此时密度模型会判断它为异常。

即，使用模型预测样本所处区域的密度，此时可以选择一个较小值$\epsilon$，假如预测的结果在$\epsilon$范围内，则认为样本处于低密度区域，表明样本处于异常状态，而预测结果若大于等于$\epsilon$，则表明处于密度足够的区域，判定为正常。

![](https://github.com/1830125598/DeepLearning/raw/42636df76450a47e0d4254eb4afb7f53ac3be50c/unsupervised%20learning/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B-%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1.png)

#### 高斯(正态)分布

* $p(x) = \frac{1}{\sqrt{2\pi}\sigma}e^{\frac{-(x - \mu)^{2}}{2\sigma^{2}}}$

* $\mu = \frac{1}{m}\sum\limits_{i = 1}^{m}x^{(i)}$

* $\sigma^{2} = \frac{1}{m}\sum\limits_{i = 1}^{m}(x^{(i)} - \mu)^{2}$

### 异常检测算法

1. 选择你认为可能能表现出异常的$n$个样本特征$x_{i}$
2. 为$n$个特征拟合参数$\mu_{1}, \ldots, \mu_{n}, \sigma_{1}^{2}, \ldots, \sigma_{n}^{2}$
   1. $\mu_{j} = \frac{1}{m}\sum\limits_{i = 1}^{m}x_{j}^{(i)}$
   2. $\sigma_{j}^{2} = \frac{1}{m}\sum\limits_{i = 1}^{m}(x_{j}^{(i)} - \mu_{j})^{2}$
3. 给出一个新的样本$x$，计算$p(x)$:

$$
\begin{aligned}
p(x) &= \prod\limits_{j = 1}^{n} p(x_{j};\mu_{j},\sigma_{j}^{2}) \\\\
     &= \prod\limits_{j = 1}^{n} \frac{1}{\sqrt{2\pi}\sigma_{j}}exp(-\frac{(x_{j} - \mu_{j})}{2\sigma_{j}^{2}}^{2})
\end{aligned}
$$

4. 当$p(x) \lt \epsilon$($\epsilon$为一个极小值，即当概率落到正态分布边缘时，则认为当前样本不在正常工作范围)时，则认为该样本为异常 

**Tips：** 本算法的思想为将样本特征标准化为正态分布函数，此时若某项特征极大或极小，则对应的概率在正态分布上就是极小的，由于样本的特征之间均是独立同分布，则总概率为各个特征的概率乘积，当某个概率极小，就会导致最后的结果极小，此时判定该样本异常。

#### 异常检测 vs 监督学习

**异常检测：**

1. 样本数量

* 当只有非常少量的正样本$(y = 1)$，类似$(0 \sim 20)$
* 并且有相对大量的负样本$(y = 0)$来尝试建立$p(x)$模型

2. 异常类型

* 异常可能性较多时，正样本可能无法覆盖所有异常方式，未来的异常可能是从未出现过的

3. 擅长解决的问题

* 诈骗检测
* 制造业-发现从未出现过的故障
* 监视数据中心的机器运行

**监督学习：**

1. 样本数量

* 正负样本数量都很多

2. 异常类型

* 需要包含足够多的正样本，来保证覆盖所有可能的异常类型

3. 擅长解决的问题

* 垃圾邮件分类
* 制造业-发现已知的故障
* 天气预报
* 疾病分类

#### 合适的特征选择

* 选择在出现异常时看取极大或极小值的特征
* 当现有特征在出现异常时表现并不明显时，可以对现有特征组成成新的特征
  * 例：出现异常时网络流量$(x_{1})$特别低，但`CPU`负载$(x_{2})$特别高
  * 此时可以组合产生新特征:
    * $x_{3} = \frac{x_{2}}{x_{1}}$，即$(\frac{\text{CPU负载}}{网络流量})$
    * $x_{4} = \frac{(x_{2})^{2}}{x_{1}}$
* 尝试多种不同的特征选择，以确保$p(x)$足够大

## 推荐系统

### 定义

这里以电影推荐系统为例。

* $n_{u}$：用户数量
* $n_{m}$：电影数量
* $n$：特征数量
* $w^{(i)}, b^{(i)}$：第$i$个用户的参数

**Tips：** 由于每个人喜好不同，那么不可能使用同一个模型去预测其喜好，即可认为对每个用户均训练一个模型。

### 代价函数

* $r(i, j)$：第$j$个用户是否对第$i$个电影做出了评分`(0-No, 1-Yes)`
* $y^{(i, j)}$：第$j$个用户对第$i$个电影的评分
* $w^{(j)}, b^{(j)}$：第$j$个用户的参数
* $x^{(i)}$：第$i$个电影的特征
* $m^{(j)}$：第$j$个用户评分的电影数量

对于用户$j$已经电影$i$，预测的结果为：$w^{(j)} \cdot x^{(i)} + b^{(j)}$

**对应代价函数：**

* $\mathop{min}\limits_{w^{(j)}b^{(j)}}J(w^{(j)}, b^{(j)})\frac{1}{2m^{(j)}}\sum\limits_{i:r(i, j) = 1}(w^{(j)} \cdot x^{(i)} + b^{(j)} - y^{(i, j)})^{2} + \frac{\lambda}{2m^{(j)}}\sum\limits_{k = 1}^{n}(w_{k}^{(j)})^{2}$

**对于所有用户的代价函数：**

对于所有用户的所有学习参数$w^{(1)}, b^{(1)}, w^{(2)}, b^{(2)}, \ldots, w^{(n_{u})}, b^{(n_{u})}$，有：

$$
J \left( 
\begin{aligned}
    w^{(1)}, \ldots, w^{(n_{u})} \\\\
    b^{(1)}, \ldots, b^{(n_{u})}
  \end{aligned}
\right)
= \frac{1}{2}\sum\limits_{j = 1}^{n_{u}}\sum\limits_{i:r(i, j) = 1}(w^{(j)} \cdot x^{(i)} + b^{(j)} - y^{(i, j)})^{2} + \frac{\lambda}{2}\sum\limits_{j = 1}^{n_{u}}\sum\limits_{k = 1}^{n}(w_{k}^{(j)})^{2}
$$

### 协同过滤算法

#### 通过参数反推特征值

给出$w^{(1)}, b^{(1)}, w^{(2)}, b^{(2)}, \ldots, w^{(n_{u})}, b^{(n_{u})}$

通过学习得到$x^{(i)}$：

* $J(x^{(i)}) = \frac{1}{2}\sum\limits_{j:r(i, j) = 1}(w^{(j)} \cdot x^{(i)} + b^{(j)} - y^{(i, j)})^{2} + \frac{\lambda}{2}\sum\limits_{k = 1}^{n}(x_{k}^{(i)})^{2}$

**Tips:** 这是所有用户对单个电影的成本函数，此时$w, b$已知，把$x$当参数去求。

对于所有特征$x^{(1)}, x^{(2)}, \ldots, x^{(n_{m})}$：

* $J(x^{(1)}, x^{(2)}, \ldots, x^{(n_{m})}) = \frac{1}{2}\sum\limits_{i = 1}^{n_{m}}\sum\limits_{j:r(i, j) = 1}(w^{(j)} \cdot x^{(i)} + b^{(j)} - y^{(i, j)})^{2} + \frac{\lambda}{2}\sum\limits_{i = 1}^{n_{m}}\sum\limits_{k = 1}^{n}(x_{k}^{(i)})^{2}$

#### 结合参数和特征的代价函数

$$
\begin{gathered}
    min \\\\
    w^{(1)}, \ldots, w^{(n_{u})} \\\\
    b^{(1)}, \ldots, b^{(n_{u})} \\\\
    x^{(1)}, \ldots, x^{(n_{m})}
\end{gathered}
J(w, b, x) = \frac{1}{2}\sum\limits_{j:r(i, j) = 1}(w^{(j)} \cdot x^{(i)} + b^{(j)} - y^{(i, j)})^{2} + \frac{\lambda}{2}\sum\limits_{j = 1}^{n_{u}}\sum\limits_{k = 1}^{n}(w_{k}^{(j)})^{2} + \frac{\lambda}{2}\sum\limits_{i = 1}^{n_{m}}\sum\limits_{k = 1}^{n}(x_{k}^{(i)})^{2}
$$

#### 梯度下降

$$
\begin{aligned}
w_{i}^{(j)} = w_{i}^{(j)} - \alpha\frac{\delta}{\delta w_{i}^{(j)}} J(w, b, x) \\\\
b^{(j)} = b^{(j)} - \alpha\frac{\delta}{\delta b^{(j)}} J(w, b, x) \\\\
x_{k}^{(i)} = x_{k}^{(i)} - \alpha \frac{\delta}{\delta x_{k}^{(i)}} J(w, b,x)
\end{aligned}
$$

### 二元标签

此时不再有数字/等级评分，而仅包含喜欢/不喜欢两种可能性(相当于从线性回归变成逻辑回归)。

#### 代价函数

预测真实标签：

* $y^{(i, j)}: f_{w, b, x}(x) = g(w^{(j)} \cdot x^{(i)} + b^{(j)})$

代价函数：

* $L(f_{w, b, x}(x), y^{(i, j)}) = -y^{(i, j)}log(f_{w, b, x}(x)) - (1 - y^{(i, j)})log(1 - f_{w, b, x}(x))$
* $J(w, b, x) = \sum\limits_{(i, j) : r(i, j) = 1} L(f_{(w, b, x)}(x), y^{(i, j)})$

### 均值归一化

当某个用户初次出现，即还未完成任何评分，那么对该用户数据进行训练可能得到的$w, x, b$均为$0$，此时若对该用户对电影的评分进行预测，那么结果就会为$0$，但这样显然是不太合理的，我们不能认为未进行评分的用户的默认评分都是$0$。

因此对每个电影获得的评分取均值，即得到了一个向量$\vec{\mu} = [\mu_1, \ldots, \mu_{m}]$

然后修改对于用户$j$，对于电影$i$的评分的预测结果为：

* $w^{(j)} \cdot x^{(i)} + b^{(j)} + \mu_{i}$

即让预测的评分以得分均值来作为基准。

**Tips：** 得到的数据矩阵可以根据具体情况来决定按行均值归一还是按列均值归一


### TensorFlow 实现

#### 例:使用TensorFlow完成梯度下降

当代价函数为$J = (wx - 1)^{2}$时，此时$f(x) = wx, y = 1$，使用`TensorFlow`进行梯度下降的代码实现如下：

```python
#表明w为需要优化的参数，同时初始值为3
w = tf.Variable(3.0)
x = 1.0
y = 1.0
alpha = 0.01

# 设定进行30次梯度下降
iterations = 30
for iter in range(iterations):
#   记录成本j所需的操作序列，并存入tape中
    with tf.GradientTape() as tape:
#       fwb实际上就是f(x)
        fwb = w * x
#       costJ就是代价函数
        costJ = (fwb - y) ** 2
#   计算导数项dJdw，并指定对w求导
    [dJdw] = tape.gradient(costJ, [w])
#   更新参数w
    w.assign_add(-alpha * dJdw)
```

#### 使用梯度下降进行协同过滤

```python
# 使用Adam优化器，并指定学习率为0.1
optimizer = keras.optimizers.Adam(learning_rate = 1e-1)

iterations = 200
for iter in range(iterations):
    with tf.GradientTape() as tape:
        #3个需要优化的参数X,W,b，均值归一化的评分向量ynorm，表明是否有评分的矩阵R，以及用户，电影数量
        cost_value = cofiCostFuncV(X, W, b, Ynorm, R, num_users, num_movies, lambda)
    grads = tape.gradient(cost_value, [X, W, b])
    # zip函数将数字重新排列成适合应用梯度函数的顺序
    optimizer.apply_gradients(zip(grads, [X, W, b]))
```

#### 查找相似内容

当我们想要找到与第$i$个样本相似的样本，即找到某个样本$k$，该样本的特征$\vec{x}^{(k)}$与$\vec{x}^{(i)}$相似(即值接近)。

那么怎么判断这两个特征是否相似呢？可以做以下运算:

* $\sum\limits_{l = 1}^{n}(x_{l}^{(k)} - x_{l}^{(i)})^{2}$

#### 协同过滤局限性

* 冷启动问题处理不佳
  * 对于一个新产品，并且用户评价很少，怎么进行评分呢？
* 没有自然的使用侧面学习或有关项目/用户的附加信息
  * 你可能知道很多用户的信息，但是并没有被使用到预测中

### 基于内容的过滤

#### 协同过滤 vs 基于内容的过滤

**协同过滤：**

* 基于用户给出的评分进行推荐

**基于内容的过滤：**

* 根据用户的特征和电影的特征进行推荐，无需用户给出评分

#### 深度学习(基于内容的过滤)

**用户网络：**

输入用户特征$x_{u}$，输出描述用户的向量$v_{u}$

**电影向量：**

输入电影特征$x_{m}$，输出描述电影的向量$v_{m}$

**预测结果：**

* $v_{u} \cdot v_{m}$
* $g(v_{u} \cdot v_{m})$用于预测$y^{(i, j)}$为$1$的可能性

![](https://github.com/1830125598/DeepLearning/raw/b149b3a4d2cc502fae4fc3ea933a3e6bdb3894c3/recommend%20system/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AE%B9%E7%9A%84%E8%BF%87%E6%BB%A4.png)

如下图，结合两个神经网络用于预测。

此时代价函数为：

* $J = \sum\limits_{(i, j):r(i, j) = 1}(v_{u}^{(j)} \cdot v_{m}^{(i)} - y^{(i, j)})^{2} + \text{NN regularization term}$

![](https://github.com/1830125598/DeepLearning/raw/cba13874e870aaaee9b2980aed61124b3f772368/recommend%20system/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AE%B9%E7%9A%84%E8%BF%87%E6%BB%A4-2.png)

#### 从大目录中选取物品推荐

1. 检索
   1. 生产一个包含大量可能推荐项目候选的列表，以覆盖可能推荐的内容
      1. 对于用户最近观看的$10$部电影，找到最相似的$10$个电影
      2. 根据用户观看最多的$3$个类型进行补充，找到最热门的$10$部电影
      3. 找到用户所在国家最热门的$20$部电影
   2. 去处重复想并去除用户已经看过/购买过的电影

![](https://github.com/1830125598/DeepLearning/raw/1a8e19fefda8d1c4655e821a160191b627787cf4/recommend%20system/%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90-%E6%A3%80%E7%B4%A2.png)

2. 排名
   1. 检索获取的列表，利用训练好的模型进行排序
   2. 根据预测用户将会给出的最高评分向用户展示

![](https://github.com/1830125598/DeepLearning/raw/704f8518fa9e6adf7834dc6b4708753894142854/recommend%20system/%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90-%E6%8E%92%E5%90%8D.png)

#### TensorFLow实现

```python
import tensorflow as tf
user_NN = tf.keras.models.Sequential([
    tf.keras.layers.Dense(256, activation = 'relu'),
    tf.keras.layers.Dense(128, activation = 'relu'),
    tf.keras.layers.Dense(32)
])

item_NN = tf.keras.models.Sequential([
    tf.keras.layers.Dense(256, activation = 'relu'),
    tf.keras.layers.Dense(128, activation = 'relu'),
    tf.keras.layers.Dense(32)
])

# 提取特征并输入到神经网络中
input_user = tf.keras.layers.Input(shape = (num_user_features))
vu = user_NN(input_user)
# vu = tf.linalg.l2_normalize(vu, axis = 1)
# 矢量归一化使其长度为1(L2归一化)
vu = tf.math.l2_normalize(vu, axis = 1)

input_item = tf.keras.layers.Input(shape = (num_item_features))
vm = user_NN(input_item)
# vu = tf.linalg.l2_normalize(vu, axis = 1)
vm = tf.math.l2_normalize(vm, axis = 1)

# 计算最终预测
output = tf.keras.layers.Dot(axes = 1)([vu, vm])

# 声明这是一个以用户和电影特征为输入的模型，同时输出为上面定义的输出
model = Model([input_user, input_item, output])

# 使用均方差损失函数
cost_fn = tf.keras.losses.MeanSquaredError()
```

## 强化学习(Reinforcement learning)

### 什么是强化学习？

* 你只需要去告诉计算机需要做什么，而不需要去告诉它该怎么做。

* 指定奖励函数而不是最优动作。 
    * 例：对于直升机：
      * 如果它飞的很好，可以每秒给它一个奖励。
      * 如果它飞的不好，可以每秒给一个负的奖励。
      * 如果它坠毁了，给它一个极大的负奖励。

### 回报(return)

#### 定义

回报即衡量智能体从某一时刻开始，未来能获得的奖励总和。

#### 折扣因子

折扣因子通常用希腊字母$\gamma$`(gamma)` 表示，取值范围在$[0, 1]$之间，核心作用是衡量 “未来奖励” 相对于 “即时奖励” 的重要性：

* 当$\gamma$接近$1$时：智能体更"看重未来"，会优先考虑长期收益(比如为了后续获得$100$分奖励，愿意暂时接受当前$0$分甚至少量负分)
* 当$\gamma$接近$0$时：智能体更"关注当下"，只重视即时奖励(比如只在意当前步的得分，忽略后续可能的高奖励)

### 决策与策略制定

#### $\pi$函数

输入状态$s$，输出策略$a$，即$\pi(s) = a$。

![](https://github.com/1830125598/DeepLearning/raw/8ce8fb3fdcf93251f61cc72c45de4fce156b5b0a/reinforcement%20learning/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-pi%E5%87%BD%E6%95%B0.png)

强化学习的目标就是找到一个策略$\pi$告诉你在任何状态$(s)$下的行动$(a = \pi(s))$使得获得的回报最大。

### 关键概念

#### states(状态)

* Mars rover(火星探测器)：6种状态
* Helicopter(直升机)：直升机的位置
* Chess(国际象棋)：棋子的位置

#### actions(动作集合)

* Mars rover(火星探测器)：左/右移动
* Helicopter(直升机)：移动直升机控制杆的所有可能方式
* Chess(国际象棋)：合法的移动方式

#### rewards(奖励)

* Mars rover(火星探测器)：100, 0, 40
* Helicopter(直升机)：+1, -1000
* Chess(国际象棋)：+1, 0, -1

#### discount factor $\gamma$(折扣因子)

* Mars rover(火星探测器)：0.5
* Helicopter(直升机)：0.99
* Chess(国际象棋)：0.995

#### return(回报)

* Mars rover(火星探测器)：$R_{1} + \gamma R_{2} + \gamma^{2} R_{3} + \ldots$
* Helicopter(直升机)：$R_{1} + \gamma R_{2} + \gamma^{2} R_{3} + \ldots$
* Chess(国际象棋)：$R_{1} + \gamma R_{2} + \gamma^{2} R_{3} + \ldots$

#### policy $\pi$($\pi$策略)

* Mars rover(火星探测器)：

![](https://github.com/1830125598/DeepLearning/raw/510f4aff52af6a6a2bc5be481bc32f71025e8a29/reinforcement%20learning/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E7%81%AB%E6%98%9F%E6%8E%A2%E6%B5%8B%E5%99%A8-pi%E7%AD%96%E7%95%A5.png)

* Helicopter(直升机)：找到策略$\pi(s) = a$
* Chess(国际象棋)：找到策略$\pi(s) = a$

#### Markov Decision Process(MDP)(马尔可夫决策过程)

未来只取决于你现在所处的位置，而不是你是如何到达这里的。

![](https://github.com/1830125598/DeepLearning/raw/98db6613def3e481707daa4caed035cb69869285/reinforcement%20learning/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96.png)

### 状态动作价值函数

#### 定义(Q-function)

$$
Q(s, a) = \begin{array}{l}
\quad \text{Return if you} \\\\
\quad \cdot \quad \text{开始于状态s} \\\\
\quad \cdot \quad \text{采取行动a(一次)} \\\\
\quad \cdot \quad \text{此后均采取最优行为}
\end{array}
$$


![](https://github.com/1830125598/DeepLearning/raw/5e9c18aa19f96c70f30dd8df0436e4df8257c944/reinforcement%20learning/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-Q%E5%87%BD%E6%95%B0.png)

**策略选择：**

* 在状态$s$能获得的最大回报为$\mathop{max}\limits_{a} Q(s, a)$
* 状态$s$最好的行动$a$是能够最大化$Q$值的$\mathop{max}\limits_{a} Q(s, a)$

#### 火星探测车代码示例

```python
import numpy as np
from utils import *

# 状态/动作数量
num_states = 6
num_actions = 2

# 奖励
terminal_left_reward = 100
terminal_right_reward = 40
each_step_reward = 0

# 折扣因子
gamma = 0.5

# 走向错误方向的可能性
misstep_prob = 0

generate_visualization(terminal_left_reward, terminal_right_reward, each_step_reward, gamma, misstep_prob)
```

#### Bellman Equationb(贝尔曼方程)

**定义：**

* $R(s)$ ：当前状态能获得的奖励
* $s$ : 当前状态
* $a$ ：当前行动
* $s^{\prime}$ ：行动$a$之后到达的状态
* $a^{\prime}$ ：在状态$s^{\prime}$将采取的行动
* $Q(s, a) = R(s) + \gamma \; \mathop{max}\limits_{a^{\prime}}Q(s^{\prime}, a^{\prime})$

#### 随机环境

**状态随机转移：**

即执行动作后，转移到的新状态不确，如：

* 执行向右移动时：
  * 有$90\%$的概率向右走(目标方向)
  * 有$10\%$的概率向左走(反方向)

**期望回报：**

* 期望回报  
  * = $Average(R_{1} + \gamma R_{2} + \gamma^{2} R_{3} + \gamma^{3} R_{4} + \ldots)$
  * = $E[R_{1} + \gamma R_{2} + \gamma^{2} R_{3} + \gamma^{3} R_{4} + \ldots]$

$Average$即在随机环境下采取策略尝试很多次(如上千次)，所获的的平均奖励，也就是期望回报。

**随机强化学习中的贝尔曼方程：**

* $Q(s, a) = R(s) + \gamma \; E[\mathop{max}\limits_{a^{\prime}}Q(s^{\prime}, a^{\prime})]$

### 连续状态空间应用

#### 直升机

**状态：**

* $x, y, z$ ： 位置
* $\phi$ ：滚转(左右翻转)
* $\theta$ ：俯仰角
* $\omega$ ：偏航
* $\dot{x}, \dot{y}, \dot{z}, \dot{\phi}, \dot{\theta}, \dot{\omega}$ ：对应状态的速度

#### 月球着陆器

**操作：**

* 什么都不做
* 左侧推进器：推动着陆器向右移动
* 右侧推进器：推动着陆器向左移动
* 主引擎：推动着陆器向上移动

**对应状态向量；**

$$
s = \left[
\begin{aligned}
x \\\\
y \\\\
\dot{x} \\\\
\dot{y} \\\\
\theta \\\\
\dot{\theta} \\\\
l \\\\
r
\end{aligned}
\right]
$$

* $x, y$ ：横坐标和纵坐标
* $\dot{x}, \dot{y}$ ：在横坐标和纵坐标上的移动速度
* $\theta$ ： 着陆器机身的角度
* $\dot{\theta}$ ： 着陆器机身的角度的变化速度(角速度)
* $l, r$ ：左右腿是否接触地面

**奖励函数：**

* 成功抵达平台：$100 \sim 140$
* 朝向或原理平台情况：靠近加分，远离扣分
* 坠毁：$-100$
* 软着陆: $+100$
* 腿着陆：$+10$
* 使用主引擎一次：$-0.3$
* 使用单侧推进器一次(左右推进器之一)：$-0.03$

**学习策略：**

目标为学习一个策略$\pi$，对于给定状态：

$$
s = \left[
\begin{aligned}
x \\\\
y \\\\
\dot{x} \\\\
\dot{y} \\\\
\theta \\\\
\dot{\theta} \\\\
l \\\\
r
\end{aligned}
\right]
$$

采取一个行动$a = \pi(s)$，使得回报最大。

此时$\gamma = 0.985$

#### 学习状态值函数

**输入**

通过将$4$个操作转换成独热编码的方式，与状态向量合并为一个向量作为神经网络的输入。

![](https://github.com/1830125598/DeepLearning/raw/acc856f912de3f5e45c6321d2c9879067b873b04/reinforcement%20learning/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E8%BE%93%E5%85%A5.png)

**训练集**

此时贝尔曼方程为：

$\mathop{\underbrace{Q(s, a)}}\limits_{x} = \mathop{\underbrace{R(s) + \gamma \; \mathop{max}\limits_{a^{\prime}}Q(s^{\prime}, a^{\prime})}}\limits_{y}$

此时$x$是已知的，$y$中一部分已知，另一部分则通过神经网络获得。

![](https://github.com/1830125598/DeepLearning/raw/088b3a87fe8c2631f1ce34219a739f0e3792c3dc/reinforcement%20learning/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E6%9C%88%E7%90%83%E7%99%BB%E9%99%86%E5%99%A8-%E8%AE%AD%E7%BB%83%E9%9B%86.png)

**Q-learning算法**

* 随机初始化神经网络，将其作为$Q(s, a)$的初始猜测
* 重复执行以下步骤
  * 在月球登陆器中执行行动，获取元组$(s, a, R(s), s^{\prime})$
  * 存储最近的$10000$个$(s, a, R(s), s^{\prime})$元组(存入经验回放池中)
  * 训练神经网络：
    * 用$x = (s, a)$和$y = R(s) + \gamma \; \mathop{max}\limits_{a^{\prime}} Q(s^{\prime}, a^{\prime})$创建$10000$个样本
    * 训练新的网络$Q_{new}$，使$Q_{new}(s, a) \approx y$
    * 令$Q = Q_{new}$


**Tips:** 以矩阵$Ax = y$为例，此时训练$A$，同时训练完成后迭代更新$y$。

![](https://github.com/1830125598/DeepLearning/raw/b522e98769b8bb5d176d03e5da28a4d2c4753bcb/reinforcement%20learning/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E6%9C%88%E7%90%83%E7%99%BB%E9%99%86%E5%99%A8-Q-learning.png)
 
#### 算法优化-改进神经网络结构

原本的神经网络在输入中包含当前的行动，为了提升效率，对神经网络进行修改，在输入中去掉代表当前行动的独热编码，同时将输出层修改成$4$个神经元，使得神经网络一次推理即可得到$4$个行动的预测结果。
 
![](https://github.com/1830125598/DeepLearning/raw/639c071287ee612f14b415133605461d23ca04d9/reinforcement%20learning/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E6%9C%88%E7%90%83%E7%99%BB%E9%99%86%E5%99%A8-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.png)

#### $\epsilon$-贪心

在某些状态$s$，有以下两种策略：

* 选项1:
  * 选择一个能使得$Q(s, a)$最大的行动$a$
* 选项2($\epsilon$-贪心策略($\epsilon = 0.05$)):
  * 在$95\%$的概率下，选择一个能使得$Q(s, a)$最大的行动$a$
  * 在$5\%$的概率下，随机选择一个行动$a$

#### mini-batch(小批量)

当训练集规模很大时，梯度下降算法就会变得很慢。

小批量梯度下降的理念是每一步不使用完整的训练集，而仅采取一个较小的子集，每次梯度下降的迭代仅需查看这个较小的子集。 

**注：** 虽然小批量梯度下降不那么可靠，但每次迭代的成本极低。

#### Soft Update(软更新/自我更新)

在强化学习中，每次迭代将会设置$Q = Q_{new}$

这里可以通过自我更新对参数进行渐进性的修改:

* $W = 0.01W_{new} + 0.99W$
* $B = 0.01B_{new} + 0.99B$

**Tips：** 通过自我更新方式可以使得强化学习算法更快收敛
